#### OpenGL ES 渲染管线与着色器

##### 一,渲染管线
管线(pippeline)也称渲染管线,因为OpenGL ES在渲染处理过程中会顺序执行一系列操作,这一系列相关的处理阶段称为OpenGl ES渲染管线,一个操作接着一个操作,提高了渲染的效率.
![2012112515314069.png](https://pic002.cnblogs.com/images/2012/81194/2012112515314069.png)
图中的阴影部分的`Vertex Shader`和`Fragment Shader`是可编程管线.可编程管线一般有脚本语言提供,方便修改,无需重新编译. ,
`Vertex Array/Buffer objects`:顶点数据来源,这是渲染管线的顶点输入,通常用`Buffer objects`效率更好 

`Vertex Shader`:`顶点着色器`通过可编程的方式实现对顶点的操作,如坐标空间转换,计算`per-vertex color`以及文理坐标.

`Primitive Assembly`:图元装配,经过着色器处理之后的顶点在图元装配阶段被装配位基本图元.OpenGL ES 支持三种基本的图元:点,线和三角.,他们是可被OpenGL ES渲染的.接着对装配好的图元进行裁剪(clip):保留完全在椎体中的图元,丢弃完全不在视椎体中图元;接着再对视椎体中的图元进行剔除处理(cull):这个过程可编码决定是剔除正面,背面还是全部剔除.

`Rasterization`:光栅化,基本的图元被转化为二维的片元(fragment),fagment表示可以被渲染到屏幕上的像素,它包括位置,颜色,纹理坐标等信息.这些值是有图元的顶点信息进行插值计算得到的.这些图元被送到片元着色器中处理,这是从顶点数据到可渲染在显设备上的像素的质变的过程.

`Fragment Shader`:片元着色器通过可编程的方式实现片元的操作,在这一阶段他接收光栅化处理之后的fragment,color,深度值,模板值作为输入.

`per-Fragment Operation`:在这一阶段对片元着色器输出的每一个片元进行一系类测试与处理.从而决定最终用于渲染像的像素,这一系列的处理过程如下:
![2012112516362077.png](https://pic002.cnblogs.com/images/2012/81194/2012112516362077.png)

`Pixel Ownership Test`:该测试决定像素在framebuffer中的位置是不是当前OpenGL ES所有,也就是说测试某个像素是否对用户可见或者被重叠窗口所遮挡.

`Scissor Test`:裁剪测试,判断像素是否在有glScissor定义的裁剪矩形内,不在该裁剪区域的像素将会被裁减掉.

`Stencil Test`：模版测试，将模版缓存中的值与一个参考值进行比较，从而进行相应的处理；

`Depth Test`：深度测试，比较下一个片段与帧缓冲区中的片段的深度，从而决定哪一个像素在前面，哪一个像素被遮挡；

`Blending`：混合，混合是将片段的颜色和帧缓冲区中已有的颜色值进行混合，并将混合所得的新值写入帧缓冲；

`Dithering`：抖动，抖动是使用有限的色彩让你看到比实际图象更多色彩的显示方式，以缓解表示颜色的值的精度不够大而导致的颜色剧变的问题。

`Framebuffer`：这是流水线的最后一个阶段，Framebuffer 中存储这可以用于渲染到屏幕或纹理中的像素值，也可以从Framebuffer 中读回像素值，但不能读取其他值（如深度值，模版值等）
##### 二,顶点着色器
![2012112517164533.png](https://pic002.cnblogs.com/images/2012/81194/2012112517164533.png)
顶点着色器接收的输入：

Attributes：由 vertext array 提供的顶点数据，如空间位置，法向量，纹理坐标以及顶点颜色，它是针对每一个顶点的数据。属性只在顶点着色器中才有，片元着色器中没有属性。属性可以理解为针对每一个顶点的输入数据。OpenGL ES 2.0 规定了所有实现应该支持的最大属性个数不能少于 8 个。

Uniforms：uniforms保存由应用程序传递给着色器的只读常量数据。在顶点着色器中，这些数据通常是变换矩阵，光照参数，颜色等。由 uniform 修饰符修饰的变量属于全局变量，该全局性对顶点着色器与片元着色器均可见，也就是说，这两个着色器如果被连接到同一个应用程序中，它们共享同一份 uniform 全局变量集。因此如果在这两个着色器中都声明了同名的 uniform 变量，要保证这对同名变量完全相同：同名+同类型，因为它们实际是同一个变量。此外，uniform 变量存储在常量存储区，因此限制了 uniform 变量的个数，OpenGL ES 2.0 也规定了所有实现应该支持的最大顶点着色器 uniform 变量个数不能少于 128 个，最大的片元着色器 uniform 变量个数不能少于 16 个。

Samplers：一种特殊的 uniform，用于呈现纹理。sampler 可用于顶点着色器和片元着色器。

Shader program：由 main 申明的一段程序源码，描述在顶点上执行的操作：如坐标变换，计算光照公式来产生 per-vertex 颜色或计算纹理坐标。

顶点着色器的输出:

Varying:varying 变量用于储存顶点着色器的输出数据,当然也储存片元着色器的输入数据.
varying变量最终会在光栅化处理阶段被线性插值.顶点着色器如果声明了varying变量,它必须被传递到片元着色器中才能被进一步传递到下一阶段,因此顶点着色器中声明的varying都应该在片元着色器中声明同名同类型的varying变量.

在顶点着色器阶段至少对应输出位置信息-即内建变量:gl_Position,其它两个可选的变量为:gl_FrontFacing和gl_PointSize.

##### 三,片元着色器
![2012112517531965.png](https://pic002.cnblogs.com/images/2012/81194/2012112517531965.png)
片元管理器接受如下输入： 

Varyings：这个在前面已经讲过了，顶点着色器阶段输出的 varying 变量在光栅化阶段被线性插值计算之后输出到片元着色器中作为它的输入，即上图中的 gl_FragCoord，gl_FrontFacing 和 gl_PointCoord。OpenGL ES 2.0 也规定了所有实现应该支持的最大 varying 变量个数不能少于 8 个。

Uniforms：前面也已经讲过，这里是用于片元着色器的常量，如雾化参数，纹理参数等；OpenGL ES 2.0 也规定了所有实现应该支持的最大的片元着色器 uniform 变量个数不能少于 16 个。

Samples：一种特殊的 uniform，用于呈现纹理。

Shader program：由 main 申明的一段程序源码，描述在片元上执行的操作。

在顶点着色器阶段只有唯一的 varying 输出变量-即内建变量：gl_FragColor。

##### 四，顶点着色与片元着色在编程上的差异

1，精度上的差异
着色语言定了三种级别的精度：lowp, mediump, highp。我们可以在 glsl 脚本文件的开头定义默认的精度。如下代码定义在 float 类型默认使用 highp 级别的精度

`precision highp float;`

在顶点着色阶段，如果没有用户自定义的默认精度，那么 int 和 float 都默认为 highp 级别；而在片元着色阶段，如果没有用户自定义的默认精度，那么就真的没有默认精度了，我们必须在每个变量前放置精度描述符。此外，OpenGL ES 2.0 标准也没有强制要求所有实现在片元阶段都支持 highp 精度的。我们可以通过查看是否定义 GL_FRAGMENT_PRECISION_HIGH 来判断具体实现是否在片元着色器阶段支持 highp 精度，从而编写出可移植的代码。当然，通常我们不需要在片元着色器阶段使用 highp 级别的精度，推荐的做法是先使用 mediump 级别的精度，只有在效果不够好的情况下再考虑 highp 精度。

2，attribute 修饰符只可用于顶点着色。这个前面已经说过了。

3，或由于精度的不同，或因为编译优化的原因，在顶点着色和片元着色阶段同样的计算可能会得到不同的结果，这会导致一些问题（z-fighting）。因此 glsl 引入了 invariant 修饰符来修饰在两个着色阶段的同一变量，确保同样的计算会得到相同的值。

###### 五，使用顶点着色器与片元着色器

shader 对象与 program 对象就相当于编译器与链接器。shader 对象载入源码，然后编译成 object 形式(就像C源码编译成 .obj文件)。经过编译的 shader 就可以装配到 program 对象中，每个 program对象必须装配两个 shader 对象：一个顶点 shader，一个片元 shader，然后 program 对象被连接成“可执行文件”，这样就可以在 render 中是由该“可执行文件”了。



